# 분할정복 알고리즘

## 원리

* 순환적으로 문제를 푸는 하향식 접근 방법
  * 주어진 문제의 입력을 더이상 나눌 수 없을 때 까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 그 해를 결합하여 원래 문제의 해를 구하는 방식
* 특징
  * 분할된 작은 문제는 원래 문제와 동일
    * 단, 입력 크기만 작아짐
  * 분할된 문제는 서로 독립적
    * 순환적 분할 및 결과 결합이 가능
* 각 순환 호출 시의 처리 과정
  * 분할: 주어진 문제를 여러 개의 작은 문제로 분할
  * 정복: 작은 문제들을 순환적으로 분할, 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환 호출 없이 작은 문제에 대한 해를 구합
  * 결합: 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구함
* 분할 과정
  * 이진 탐색
    * n을 반으로 쪼갠 뒤 한쪽만 연속해서 분할
  * 합병 정렬
    * n을 반으로 쪼갠 뒤 연속해서 쪼갬
  * 퀵 정렬
    * 두개로 나누는데 크기를 모르기 때문에 일정하지 않게 분할함
  * 선택 문제
    * 크기가 일정하지 않게 분할하나 한쪽을 쓰지 않음

T(n)=2T(n/2)+Θ(n), T(1)=Θ(1) → Θ(nlogn) → 합병 정렬의 수행 시간, 퀵 정렬의 최선 수행 시간

T(n)=T(n-1)+Θ(1), T(1)=Θ(1) → Θ(n)

T(n)=T(n/2)+Θ(1), T(1)=Θ(1) → Θ(logn) → 이진 탐색

T(n)=T(n-1)+Θ(n), T(1)=Θ(1) → Θ(n2) → 퀵 정렬의 최악 수행 시간

## 이진 탐색

* 정렬된 상태의 데이터에 대해 적용 가능한 효과적인 탐색 방법
  * 오름차순으로 정렬되었다고 가정
* 탐색 방법
  * 배월의 가운데 원소와 탐색키 x를 비교
    1. 탐색키 = 가운데 원소 => 탐색 성공
    2. 탐색키 < 가운데 원소 => 이진 탐색(크기 1/2의 왼쪽 부분배열) 순환 호출
    3. 탐색키 > 가운데 원소 => 이진 탐색(크기 1/2의 오른쪽 부분 배열) 순환 호출
* 탐색을 반복할 때 마다 대상 원소가 1/2씩 감소

* 분할: 배열의 가운데 원소를 기준으로 왼쪽과 오른쪽 부분배열로 분할. 탐색키와 가운데 원소가 같으면, 해당 원소의 배열 인덱스를 반환/종료
* 정복: 탐색키 x가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출 크면 오른쪽 부분배열을 대상으로 이진탐색을 순환 호출
* 결합: 부분배열에 대한 탐색 결과가 직접 반환되므로 결합이 불필요

* 입력 크기 n일 때 최대 분할 횟수는?
  * n / 2^k = 1 -> k = logn
* 최대 비교 횟수 -> 최대 분할 횟수 + 1

### 특징

* 입력이 정렬된 리스트에 대해서만 적용 가능
* 삽입/삭제 연산 시 데이터 정렬 상태 유지가 필요
  * 평균 n/2개의 데이터 이동이 발생
    * 삽입/삭제가 빈번한 응용에는 부적합

## 퀵정렬

* 특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
  * 오름차순으로 정렬되었다고 가정
* 피벗 pivot
  * 두 부분배열로 분할할 때 기준이 되는 특정 원소
    * 보통 주어진 배열의 첫번째 원소로 지정

### 개념

* 피벗이 제자리를 잡도록 하여 정렬하는 방식
* 왼쪽 부분 배열의 모든 값 < 피벗 < 오른쪽 부분 배열의 모든 값

* 분할: 피벗을 기준으로 주어진 배열을 두 부분배열로 분할
* 정복: 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬
* 결합: 필요 없음

### 성능 분석

* 극심한 불균형적 분할
  * 피벗만 제자리를 잡고, 나머지 모든 원소가 하나의 부분배열이 되는 경우
  * 피벗이 항상 부분배월의 최솟값 또는 최댓값이 되는 경우
  * 입력 데이터가 정렬된 경우 AND 피벗을 배열의 처음 원소로 지정한 경우
* 가장 균형적인 분할
  * 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우
  * 피벗이 항상 부분배월의 중간값이 되는 경우
* 평균적인 경우
  * 부분배열의 모든 분할 비율에 따른 수행 시간의 평균
    * 피벗은 동일한 확률로서 분할 수 배열의 어느곳이나 위치 가능

### 특징

* 최선/평균의 경우 -> O(nlogn)
* 최악의 경우 -> O(n^2)
  * 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 매우 높음
    * 배열에서 임의의 값을 선택해서 배열의 처음 원소와 서로 교환한 수 정렬 수행