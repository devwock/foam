# 분할정복 알고리즘 (2)

## [복습] 분할정복 방법의 원리

* 순환적으로 문제를 푸는 하향식 접근 방법
  * 주어진 문제의 입력을 더이상 나눌 수 없을 때 까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 그 해를 결합하여 원래 문제의 해를 구하는 방식
  * 분할 - 정복 - 결합
* 특징
  * 분할된 문제는 원래 문제와 동일(입력 크기만 감소)하고 서로 독립접
* 적용 알고리즘
  * 이진 탐색, 퀵 정렬, 합병 정렬, 선택 문제

## 합병 정렬

* 배열을 동일한 크기의 두 개의 부분배열로 분할하고, 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦
* 분할: 입력 크기 n인 배열을 크기 n/2인 두 부분배열로 분할
* 정복: 각 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 두 부분배열을 정렬
* 결합: 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦

* 합병 함수 Merge() 수행 시간
  * 두 부분배열 간의 비교 횟수 -> n/2 ~ n - 1
  * 최악의 경우 세타(n)
  * 입력된 데이터 개수만큼의 저장 장소가 추가로 필요
* 성능 분석
  * 합병 정렬 MergeSort() 수행 시간
    * 크기 n/2인 두 번의 MergeSort() 순환 호출 + 한 번의 합병 Merge()
    * T(n) = O(nlogn)

## 선택 문제

* n개의 우너소가 임의의 순서로 정렬된 배열 A(0..n-1)에서 i번째로 작은 원소를 찾는 문제
  * i = 1 -> 최소값
  * i = n/2 -> 중간값
  * i = n -> 최대값
* 직관적인 방법
  * 오름차순으로 정렬한 후 i번째 원소를 찾는 방법 -> O(nlogn)
  * 최소값 찾는 과정을 i번 반복((i - 1)번째 까지는 최소값을 찾은 후 삭제) -> O(in)
* 최악 O(n^2), 평균 O(n)알고리즘
* 최악 O(n), 평균 O(n)알고리즘

* 최소값 찾기
  * 각 데이터를 하나씩 모두 비교하는 방법
    * n개의 데이터에 대해서는 최소한 n-1번의 비교가 필요 -> O(n)
* 최소값과 최대값 모두 찾기
  * 최소값을 찾은 후 최대값을 찾는 방법
    * n개의 데이터에서 최소값을 찾는데 (n-1) 번의 비교 + (n-1)개의 데이터에서 최대값을 찾는데 (n-2)번의 비교 -> 2n-3번의 비교
  * 2n-3번의 비교가 아닌 3/2n - 2 번의 비교로 수행 가능
    * 모든 원소를 두 개씩 짝을 이루어 동시에 최소값/최대값과 비교

### i번째로 작은 원소 찾기 - 최악 O(n^2), 평균 O(n)

* 개념과 원리
  * 퀵 정렬의 분할함수 Partition()을 순환적으로 적용
  * 분할: 피벗을 기준으로 주어진 배열을 두 부분배열로 분할, i가 피벗의 인덱스와 같으면 피벗의 값을 반환하고 종료
  * 정복: 인덱스 i가 포함된 부분배열에 대해서 선택 알고리즘을 순환적으로 적용
  * 결합: 필요없음
  * 성능 분석
    * 최악의 경우 = 퀵 정렬의 최악의 경우
      * 분할 함수가 항상 하나의 부분배열만 생성하는 경우
      * 오름차순에서 정렬된 상태에서 i=n을 찾는 경우 -> 분할 함수 호출할 때 마다 피벗의 인덱스는 1씩 증가 -> Partition()을 O(n)번 호출 = O(n^2)
      * 해결책 -> 항상 일정한 비율의 두 부분배열로 분할 -> 최악의 경우에도 O(n)
    * 평균적인 경우 O(n)

### i번재로 작은 원소 찾기 - 최악 O(n), 평균 O(n)

* 개념과 원리
  * 특정한 성질을 만족하도록 피벗을 선택
    * 항상 일정한 비율의 두 부분배열로 분할
* 피벗 선택 방법
  * 크기 n인 배열 원소를 5개씩 묶어 n/5개의 그룹을 형성
    * 5의 배수가 되지 않아 그룹을 형성하지 못한 채 남는 원소는 그대로 남겨 둠
  * 각 그룹에 대해서 중간값을 찾음
  * n/5개의 중간값을을 대상으로 다시 중간값을 찾음 = 중간값들의 중간값 = 피벗
* 부분 배열로의 분할 비율
