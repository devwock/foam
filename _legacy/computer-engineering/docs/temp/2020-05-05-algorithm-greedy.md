# 욕심쟁이 알고리즘

## 원리

* 해를 구하는 일련의 선택 단계마다 전후 단계의 선택과는 무관하게 해당 단계에서 가장 최선이라고 여겨지는 국부적인 최적해를 선택함으로써 전체적인 최적해를 구하는 방법
| 동적 프로그래밍 | 욕심쟁이 |
| :--: | :--: |
| 최적화 문제 해결에 주로 사용 |
| 최적성의 원리가 적용된 방법 |
| 소문제이 여러 최적해로부터 다음 크기의 문제에 대한 최적해가 결정 -> 항상 전체적인 최적해를 구함 | 소문제(각 단계)에 대해서 하나의 최적해만을 고려 -> 전체적인 최적해를 구하지 못할 수 있음 |

* 한계
  * 각 단계의 최적해를 구했다고 전체 최적해가 되지 않는다.
  * 욕심쟁이 방법으로 해를 구할 수 없는 문제도 많다.

## 동전 거스름돈 문제

* 고객에게 돌려줄 거스름돈이 있을 때 고객이 받을 동전의 개수를 최소로 하여 거스름돈을 돌려주는 방법을 찾는 문제
  * 동전의 종류: 500, 100, 50, 10
* 기본 아이디어
  * 거스름돈의 액수를 초과하지 않는 조건 하에서 단순히 액면가가 가장 큰 동전부터 욕심을 부려 최대한을 사용하여 거스름돈을 구함
  * O(n)
* 동전의 액면가가 임의로 주어지는 일반적인 경우
  * 500, 120, 100, 50, 10
  * 욕심쟁이 방법을 적용하면 500, 120, 3x10 -> 5개의 동전이 필요
  * 최적해: 500, 100, 50x1 -> 3개
  * 일반적인 거스름돈 문제는 욕심쟁이 방법으로 해결 불가

## 배낭 문제

* 최대 용량 M인 하나의 배낭과 n개의 물체
  * 각 물체 i에는 물체의 무게 wi와 해당 물체를 배낭에 넣을 때 얻을 수 있는 이익 pi
* 배낭의 용량을 초과화지 않는 범위 내에서 배낭에 들어있는 물체의 이익의 합이 최대가 되도록 물체를 넣는 방법(또는 최대 이익)을 구하는 문제
  * **물체를 쪼개서 넣을 수 있다고 가정**
* 기본 아이디어: 물체의 무게는 적으면서도 이익이 가장 큰 물체부터 골라서 욕심을 내어 최대한 넣음
  * 단위 무게당 이익이 가장 큰 물체부터 최대한 배낭에 넣는 과정을 반복, 물체를 통쨰로 넣을 수 없으면 남은 배낭의 용량만큼 물체를 쪼개서 넣음
  * 단위무게당 이익을 구함 -> 내림차순 정렬하여 넣음
  * O(2n) + 정렬시간 -> O(nlogn)
* 0/1 배낭문제
  * 물체를 쪼갤 수 없는 형태의 배낭 문제
  * 욕심쟁이 방법으로 풀 수 없게 된다.

## 최소 신장 트리

* 신장트리: 가중 무방향 그래프에서 모든 정점을 포함하는 연결된 트리
  * 간선의 가중치는 있으면서 방향은 없다.
  * 사이클이 형성되면 안된다.
  * 정점이 n개이면 트리에는 n-1개의 간선이 존재
* 최소 신장 트리
  * 간선(u,v)마다 가중치 w(u,v)를 가진 연결된 무방향 그래프 G=(V,E)에 대해서 다음을 만족하는 트리 G'=V, E'
* 알고리즘
  * 크루스칼 알고리즘
  * 프림 알고리즘

* 크루스칼 알고리즘
  * 간선이 하나도 없는 상태에서 시작해서 가중치가 가장 작은 간선부터 하나씩 사이클을 만들지 않으면서 추가시키는 방법
  * 서로 다른 연결 성분에 속하는 정점을 잇는 최소 가중치의 간선을 선택
    * n개의 정점을 서로 다른 연결 성분으로 구성된 상태에서 시작해서, 간선이 추가될 때 마다 연결 성분들이 합쳐지게 되고, 최종적으로 하나의 연결 성분을 생성
  * 간선을 가중치 순으로 정렬, 사이클을 형성하지 않도록 계속 연결
  * O(|E|log|E|)

* 프림 알고리즘
  * 임의의 한 정점에서 시작해서 연결된 정점을 하나씩 선택해 나가는 방법
    * 이미 선택된 정점에 부수된 가중치가 최소인 간선을 추가하는 방법
      * 이미 선택된 정점의 집합 S와 미선택 정점의 집합 V-S를 잇는 간선 중에서 가중치가 최소인 간선을 선택해서 추가해 나가는 방법
  * 인접 행렬의 경우 (O|V|^2)
  * 인접 리스트 + 힙 사용: O((|V+|E|)log|V|)

## 최단 경로

* 가중 방향 그래프에서 두 저점을 연결하는 경로 중에서 간선의 가중치의 합이 가장 작은 경로
  * 플로이드 알고리즘: 모든 정점간의 최댄 경로, 동적 프로그래밍 방법 적용, O(|V|^3), 가중치의 합이 음수인 사이클이 없다고 가정
  * 다익스트라: 특정한 하나의 정점에서 다른 모든 정점으로서의 최단 경로("단일 출발점 최단 경로"), 욕심쟁이 방법 적용, O(|V|^2), 음의 가중치를 갖는 간선이 없다고 가정
* 다익스트라 알고리즘
  * 거리 d[v]
    * 출발점에서 현재까지 선택된 정점 집합 S를 경유하여 정점 v에 이러는 최소 경로의 길이
  * 출발점에서 시작하여 거리 d[]가 최소인 정점을 차례로 선택하여 최단 경로를 구하는 방법
    * 초기화 -> 출발점 d[s]=0, 나머지 모든 정점 v의 d[v]=무한대, 선택 정점 집합 S={}
    * 미선택 정접 집합 V-S에서 d[]가 가장 작은 정점 u를 선택
      * u의 인접 정점에 대해서 u를 경유하는 거리와 기존 거리 중에서 작은 것을 새로운 거리값으로 조정
  * 인접행렬-> O(|V|^2)
  * 인접리스트 + 힙: O((|V+|E|)log|V|)
  * 프림 알고리즘과 성능이 같음
  * 음의 가중치를 갖는 간선이 없어야 함

## 작업 스케쥴링 문제

* 가장 적은 개수의 기계를 사용해서 작업 간의 충돌이 발생하지 않도록 모든 작업을 기계에 할당하는 문제
  * 작업이 시작되면 중단됨 없이 해당 기계에서 완료되어야 함
    * 작업 간 충돌 -> 한 기계에서 두 개 이상의 작업이 동시에 수행되는 것
* 기본 아이디어
  * 각 단계에서 시작 시간이 빠른 작업을 우선적으로 선택
    * 충돌이 발생하지 않으면 해당 기계에 배정
    * 충돌이 발생하면 새로운 기계에 할당
  * 시작 시간의 오름차순으로 정렬 (시작 시간이 빠른 순대로)
  * O(nlogn)

## 작업 선택 문제

* 하나의 기계만들 사용해서 충돌 없이 최대 개수의 작업을 기계에 할당하는 문제
* 각 단계에서 완료 시간이 빠른 작업을 우선적으로 선택
  * 충돌이 발생하지 않으면 기계에 배정
  * 충돌이 발생하면 해당 작업을 버림
* O(nlogn)

## 허프만 코딩

* 문자의 빈도 또는 확률 정보를 이용하는 통게적 압축 방법
  * 텍스트에서 각 문자가 출현하는 빈도 수에 따라 다른 길이의 부호를 부여
  * 출현 빈도수가 높은 문자 -> 짧은 코드
  * 출현 빈도수가 낮은 문자 -> 긴 코드
* ababcdbad
  * 8비트 아스키 -> 9문자 x 8비트 = 72비트
  * 고정길이 변환코드로 표현하는 경우
    * a:00 b:01 c:10 d:11 -> 9문자 x 2비트 = 18비트
  * 빈도수에 따라 가변 길이 변환 코드
    * a:3 b:3 c:1 d:2
    * a:0, b:1, c:00, d:01 -> 12비트
    * 디코딩의 모호성이 발생함
* 접두부 코드
  * 각 문자에 부여된 이진코드가 다른 문자에 부여된 이진 코드의 접두부가 되지 않는 코드
* 허프만 코드
  * 접두부 코드, 최적 코드
    * 최적 코드 -> 인코딩된 메시지의 길이가 가장 짧은 코드
  * 인코딩 과정
    1. 주어진 텍스트에서 각 문자의 출현 빈도수를 계산
    2. 각 문자의 빈도수를 이용하여 허프만 트리를 생성하여 각 문자에 이진코드를 부여
    3. 주어진 텍스트의 각 문자를 코드로 변환하여 압축된 텍스트를 생성

* 허프만 트리
  * 허프만 코딩에서 각 문자에 이진 코드를 부여하기 위해서 상향식으로 만드는 이진트리
    * 욕심쟁이 방법 사용
    * 리프 노드가 각 문자를 표시하는 전 이진트리
  * 각 문자가 개별적인 티리인 상태에서 시작해서 빈도수가 작은 두 트리를 합쳐서 큰 트리를 생성하는 과정을 반복
    * 각 노드는 빈도수로 표시
    * 좌우의 두 간선은 각각 0과 1로 레이블 됨
    * 합쳐지는 두 트리를 자식 노드로 갖는 부모 노드로 생성
      * 부모 노드의 빈도수는 두 자식 노드의 빈도수의 합
* 허프만 코드는 유일하지 않음

* 디코딩
  * 압축된 스트링을 처음부터 차례대로 읽으면서 주어진 접두부 코드와 일치하는 코드가 나오면 해당 문자로 변환
  * 성능: 호프만 트리로 만들때: O(nlogn) -> O(nlongn+m)

* 특징
  * 각 문자의 빈도수를 모르는 경우 주어진 텍스트를 두 번 읽음
    * 각 문자의 빈도수 계산
    * 텍스트를 읽으면서 실제 인코딩
    * 이 경우 속도가 상당히 느려져 실용성이 없음
  * 압축된 데이터를 디코딩하려면
    * 각 문자의 빈도수, 허프만 트리에 대한 정보, 문자 집합 정보가 필요
      * 압축된 데이터의 헤더로서 필요한 정보 제공 -> 실제 압축률 저하