---
layout: post
title: "스케쥴링 알고리즘"
excerpt: "프로세스와 스레드의 정의"
categories: [OS]
tags: [OS]
author: devwock
mermaid: true
comments: true
---

## 목차

* 목차
{:toc}

## 스케쥴링 성능 평가 기준

* 평균 대기시간
  * 각 프로세스가 수행 완료될 때 까지 **준비 큐에서 기다리는 시간** 합의 평균 값

* 평균 반환시간
  * 각 프로세스가 **생성된 시점부터 수행이 완료된 시점**까지 소요 시간의 평균 값

| 프로세스 | 대기시간 | 반환시간 |
| --- | --- | --- |
| A | 0 ~ 2: 2 | 0 ~ 5: 5 |
| B | 1 ~ 5: 4 | 1 ~ 9: 8 |
| === | === | === |
| 평균 | 평균 대기 시간: 3 | 평균 반환 시간: 6.5 |

## 다양한 스케쥴링 알고리즘

### FCFS (First Come First Served)

* 비선점 스케쥴링 알고리즘 -> 인터럽트 되지 않음
* 준비 큐에 도착한 순서에 따라 디스패치
* 장점: 가장 단순함
* 단점
  * 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 실행될 수 있음
  * 프로세스의 도착 순서에 따라 평균 반환 시간이 크게 증가

| 프로세스 | CPU 사이클 | 도착시간 |
| --- | --- | --- |
| A | 6 | 0 |
| B | 3 | 0 |
| C | 1 | 0 |
| D | 4 | 0 |

1. 동시에 도착하지만 ABCD 순서대로 도착한다.
2. A가 먼저 들어왔으므로 A부터 디스패치된다.
3. A는 6만큼 시간을 사용하고 종료된다.
4. B가 디스패치된다.
5. 반복

#### 도착 순서 ABCD

| 프로세스 | 대기시간 | 반환시간 |
| --- | --- | --- |
| A | 0: 0 | 0 ~ 6: 6 |
| B | 0 ~ 6: 6 | 0 ~ 9: 9 |
| C | 0 ~ 9: 9 | 0 ~ 10: 10 |
| D | 0 ~ 10: 10 | 0 ~ 14: 14 |
| === | === | === |
| 평균 | 평균 대기 시간: 6.25 | 평균 반환 시간: 9.75 |

#### 도착 순서 CBDA

| 프로세스 | 대기시간 | 반환시간 |
| --- | --- | --- |
| C | 0: 0 | 0 ~ 1: 1 |
| B | 0 ~ 1: 1 | 0 ~ 4: 4 |
| D | 0 ~ 4: 4 | 0 ~ 8: 8 |
| A | 0 ~ 8: 8 | 0 ~ 14: 14 |
| === | === | === |
| 평균 | 평균 대기 시간: 3.25 | 평균 반환 시간: 6.75 |

### SJF (Shortest Job First)

* 비선점 스케쥴링 알고리즘
* 준비 큐에서 기다리는 프로세스 중 실행 시간이 가장 짧을 것으로 예상되는 것을 먼저 디스패치
* 장점: 일괄처리 환경에서 구현하기 쉬 움
* 단점: 
  * 실행 예정 시간 길이를 사용자의 추정치에 의존하기 때문에 실제로는 먼저 처리할 작업의 CPU 시간을 예상할 수 없음
  * 긴 작업이 무한정 기다릴 수 있음

#### 도착 시간이 다른 경우

| 프로세스 | CPU 사이클 | 도착시간 |
| --- | --- | --- |
| A | 6 | 0 |
| B | 3 | 1 |
| C | 1 | 2 |
| D | 4 | 3 |

| 프로세스 | 대기시간 | 반환시간 |
| --- | --- | --- |
| A | 0: 0 | 0 ~ 6: 6 |
| B | 1 ~ 7: 6 | 1 ~ 10: 9 |
| C | 2 ~ 6: 4 | 2 ~ 7: 5 |
| D | 3 ~ 10: 7 | 3 ~ 14: 11 |
| === | === | === |
| 평균 | 평균 대기 시간: 4.25 | 평균 반환 시간: 7.75 |

### SRT (Shortest Remaining Time)

* 선점 스케쥴링 알고리즘
* 실행이 끝날 때 까지 남은 시간 추정치가 가장 짧은 프로세스를 먼저 디스패치
* 장점:
  * SJF 보다 평균 대기시간이나 평균 반환시간에서 효율적
  * 대화형 운영체제에 유용
* 단점:
  * 각 프로세스의 실행 시간 추적 필요
  * 선점을 위한 문맥교환 필요
  * SJF보다 오버헤드가 큼

| 프로세스 | CPU 사이클 | 도착시간 |
| --- | --- | --- |
| A | 6 | 0 |
| B | 3 | 1 |
| C | 1 | 2 |
| D | 4 | 3 |

| 프로세스 | 대기시간 | 반환시간 |
| --- | --- | --- |
| A | 0, 1 ~ 9, : 8 | 0 ~ 14: 14 |
| B | 2 ~ 3: 1 | 1 ~ 5: 4 |
| C | 2 ~ 2: 0 | 2 ~ 3: 1 |
| D | 3 ~ 5: 1 | 3 ~ 9: 4 |
| === | === | === |
| 평균 | 평균 대기 시간: 2.75 | 평균 반환 시간: 6.25 |

### RR (Round Robin)

* 선점 스케쥴링 알고리즘
* 준비 큐에 도착한 순서에 따라 디스패치하지만 정해진 시간 할당량에 의해 실행을 제한
* 시간 할당량 안에 완료되지 못한 프로세스는 준비 큐의 맨 뒤로 감
* 장점:
  * CPU를 독점하지 않고 공평하게 사용
  * 대화형 운영체제에 유용
* 단점:
  * 시간 할당량이 너무 크면 FCFS랑 같아짐
  * 시간 할당량이 너무 작으면 문맥 교환에 따른 오버헤드가 크게 증가함

### HRN (Highest Response Ratio Next)

* 비선점 스케쥴링 알고리즘
* 준비큐에서 기다리는 프로세스 중 응답비율이 가장 큰것을 먼저 디스패치

응답비율 = (대기시간 + 예상실행시간) / 예상실행시간 = 대기시간 / 예상실행시간 + 1

* 예상 실행 시간이 짧을수록, 대기시간이 길수록 응답 비율이 커짐
* 장점: SJF의 단점 보완 (오래 기다리면 아무리 큰 작업도 응답비율이 커짐)

### 다단계 피드백 큐

* 선점 스케쥴링 알고리즘
* I/O 중심 프로세스와 CPU 중심 프로세스의 특성에 따라 서로 다른 할당량 부여
* n개의 단계 (단계 1 ~ 단계 n)
* 각 단계마다 하나씩의 큐가 존재
* 단계가 커질수록 시간 할당량도 커짐

* 신규 프로세스는 단계 1의 ㅋㅍ에서 FIFO 순서에 따라 CPU 점유
* 입출력 이벤트가 발생하면 CPU를 양보하고 대기상태로 갔다가 다시 준비상태가 될 때 현재와 동일한 단계의 큐로 배치
* 시간 할당량을 다 썼지만 프로세스가 종료되지 않았다면 다음 단계의 큐로 이동 배치
* 마지막 단계 n에서는 RR 스케쥴링 방식으로 동작
* 단계 k의 큐에 있는 프로세스가 CPU를 할당받으려면 단계 1 ~ k-1 까지 모둔 큐가 비어있어야 함
* 장점: I/O 위주 프로세스(대화형)는 높은 우선권 유지
* 연산 위주의 CPU 중심 프로세스는 낮은 우선권이지만 긴 시간 할당량 가짐

### 적응형 다단계 피드백 큐 스케쥴링

* 시간 할당량을 다 쓰기전에 CPU를 반납하는 경우 하나 작은 단계의 큐로 이동 배치
* 연산 위주의 프로세스가 I/O 위주로 바뀐다면 점점 작은 단계로 배치 가능