# 동적 프로그래밍

## 원리

* 문제의 크기가 작은 소문제에 대한 해를 저장해놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식 접근 방법
  * 각 작은 문제는 원래의 문제와 동일한 문제이지만 입력의 크기만 작음
  * 입력 크기가 아주 작은 단순한 문제가 되면 쉽게 해를 구할 수 있고, 이를 테이블에 저장
  * 이후 해당 소문제의 해가 필요할 떄 마다 테이블에 저장된 결과를 바로 이용
* 동적 **프로그래밍** -> 동적 계획법
  * 컴퓨터에서의 프로그램과는 무관, 해를 구축하는 테이블을 이용한다는 의미
* 최솟값/최댓값을 구하는 최적화 문제에 적용

* 최적화 문제에 동적 프로그래밍 방법을 적용하려면?
  * 최적성의 원리를 반드시 만족시켜야 함
    * 주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 최적해로 구성된다.
* 처리 과정
  1. 주어진 문제에 대해서 최적해를 제공하는 점화식을 도출
  2. 가장 작은 소문제로부터 점화식의 해를 구한 뒤 이를 테이블에 저장
  3. 테이블에 저장되어 있는 소문제의 해를 이용하여 점차적으로 큰 상위 문제의 해를 구함

| 분할 정복 방법 | 동적 프로그래밍 방법 |
| :--: | :--: |
| 하향식 접근 방법 | 상향식 접근 방법 |
| 상위 레벨의 큰 문제를 순환적으로 부분 배열로 분할하고, 이들의 해를 결합하여 원래 문제를 해결하는 방법 | 입력 크기가 작은 소문제들을 모두 해결하여 해를 테이블에 저장한 후, 이 해들을 이용하여 보드 큰 크기의 문제를 해결하는 방법 |
| 분할된 작은 문제들은 서로 독립적 | 소문제들이 서로 독립적이지 않고, 중복되는 부분이 존재 |
| 이진 탐색, 합병 정렬, 퀵 정렬, 선택 문제 | 피보나치 수열, 연쇄 행렬 곱셈, 스트링 편집, 거리, 모든 정점 간의 최단 경로 (플로이드 알고리즘), 저울 문제 |

## 피보나치 수열

* 0일땐 0, 1일땐 1, 이외에는 전과 전전의 합으로 구성됨
  * 0, 1, 1, 2, 3, 5, 8...
* 시간 복잡도는 O(n)
* 분할 정복 방법을 적용하면?
  * 순환 형태 알고리즘으로 재귀호출로 만들 수 있음
  * 소문제가 독립이 아니기 때문에 중복된 계산이 필요 -> 매우 비효율적

## 연쇄 행렬 곱셉

* n개의 행렬을 연쇄적으로 곱하는 경우
  * 결합 법칙 성립
* 연쇄 행렬 곱셈 문제
  * n개의 행렬을 연쇄적으로 곱할 때 최적의 곱셈 순서를 구하는 문제
    * 최소의 기본 곱셈 횟수를 가진 행렬의 곱셈 순서를 구하는 문제

### 개념과 원리

* 기본 곱셈
  * 행렬 원소끼리의 곱셈
  * 곱셈 순서를 바꿔 최소한의 곱셈을 사용할 수 있도록 알고리즘 작성
* 최적성의 원리
  * n개의 행렬을 곱하는 최적의 순서는 n개 행렬의 어떤 부분집합을 곱하는 최적의 순서를 포함
  * 부분 문제들의 최적해로 n개 행렬을 곱하는 최적의 순서를 구할 수 있음 -> 최적성의 원리가 성립 -> 동적 프로그래밍 사용
  * C(i, j) -> 행렬 M1부터 Mj까지 곱하기를 수행하는데 필요한 곱셈의 최소 횟수
  * C(i, i) -> 0
  * C(i, j) = mini<=k<=j-1 { C(i, k) + C(k+1, j) + di-1 dk dj}
  * 테이블 만들고 계산
  * P[i][j]=k -> i부터 j까지 행렬을 곱할 때 최적의 순서로 갈라지는 지점이 k이다
  * O(n^3)

## 스트링 편집 거리 문제

* 두 문자열 X와 Y 사이의 편집 거리
  * 두 문자열 사이의 근접성 또는 유사성을 판단하는 척도
  * X=x1x2x3... Y=y1,y2,y3...
  * 문자열 X를 Y로 변환하는데 필요한 전체 편집 연산에 대한 최소 비용
    * 특정 위치에 새 문자를 삽입하는 연산
    * 특정 위치의 문자를 삭제하는 연산
    * 특정 위치의 문자를 다른 문자로 변경하는 연산
* 최적성의 원리
  * X와 Y사이의 편집 거리는 이들의 부분 문자열 사이의 편집 거리를 포함
* 성능: O(nxm)
* P(i, j) <- E(i, j)로 선택되는 최소값이 어떤 연산으로 결정되는지를 표시 -> 적용된 편집 연산을 구할 수 있음

## 모든 정점 간의 최단 경로

* 두 정점 간의 최단 경로
  * 가중 방향 그래프에서 두 정점을 연결하는 경로 중에서 간선의 가중치의 합이 가장 작은 경로
* 유형
  * 하나의 특정 정점에서 다른 모든 정점으로의 최단 경로
    * 다익스트라 알고리즘(욕심재잉 방법)
  * 모든 정점에서 다른 모든 정점으로의 최단 경로
    * 플로이드 알고리즘

* 모든 정점 간의 최단 경로
  * 가정 -> 가중치의 합이 음수인 사이클은 존재하지 않음
* 플로이드 알고리즘
  * 동적 프로그래밍 방법 작용
  * 간선의 인접 형렬 표현을 활용하여 경유할 수 있는 정점의 범위가 1인 경로부터 시작헤서 |V| 까지의 경로까지 단계적으로 범위를 늘려가면서 모든 정점 간의 최단 경로를 구하는 알고리즘
  * 성능: |V|^3 (정점의 갯수)
  * 최단 경로 자체를 구할 수 있음

## 저울 문제

* 양팔 저울, n개의 추, 각 추의 무게 wi (1<= i <= n)
* 무게 M인 물체를 양팔 저울로 달 수 있는지 확인하는 문제
* 물체 k의 증가를 추의 무게에 최대공약수 단위로 증가시키면 더 효율적
* 물체의 무게가 2^n보다 크면 모든 경우를 따져보는 직관적인 방법보다 비효율적
  * 직관적 알고리즘 -> n개의 추로 조합 가능한 모든 경우의 수 -> O(2^n)
  * M>2^n이면 nM>n2^2>2^n이므로 O(nM)인 알고리즘이 직관적인 알고리즘보다 비효율적
* M과 wi가 정수가 아니면 동적 프로그래밍 방법 적용 불가
  * 추의 무게와 물체의 무게에 제한 없는 저울 문제 -> 되추적 알고리즘
