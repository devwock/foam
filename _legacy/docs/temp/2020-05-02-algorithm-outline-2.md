# 알고리즘 소개 (2)

## 알고리즘 설계

* 주어진 문제, 속성, 조건 등의 매우 다양
  * 일반적이고 범용의 기법은 미존재
* 대표적 설계 기법
  * 분할 정복 방법
  * 동적 프로그래밍
  * 욕심쟁이

## 알고리즘 분석

* 정확성 분석
  * 유효한 입력, 유효한 시간 내에 정확한 결과를 생성하는지
    * 다양한 수학적 기법을 사용하여 이론적 증명이 필요하다.
* 효율성 분석
  * 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
  * 메모리양 -> 공간 복잡도
    * 정적 + 동적
  * 수행 시간 -> **시간 복잡도**

* 시간 복잡도
  * 알고리즘을 프로그램으로 구현, 실행하여 실제 수행 시간 측정
    * 일반적이지 않음
      * 컴퓨터 속도, 언어, 작성 방법, 컴파일러에 종속적
  * **알고리즘이 수행하는 기본적인 연산의 횟수의 합**
    * 시간 복잡도에 영향을 미치는 요인
      * 입력으로 제공되는 데이터 크기 (입력크기)
      * 입력 데이터의 상태
  * 입력크기 n이 증가하면 수행 시간도 증가
    * 단순히 단위 연산의 개수가 아닌, **입력 크기의 함수**로 표현
  * 입력 데이터의 상태에 종속적
    * 평균 수행 시간
    * 최선 수행 시간
    * **최악 수행 시간** <- 시간 복잡도 따질 때 일반적으로 사용

## 점근 성능

* 입력 크기 n이 무한대로 커짐에 따라 결정되는 성능
  * 수행 시간의 다항식 함수에서 **최고차항**만을 계속 없이 취해서 표현
    * 수행 시간의 어림값, 수행 시간의 증가 추세 파악이 용이 -> 알고리즘의 우열을 표현
* 표기법
  * Big-oh 점근적 상한
    * 어떤 양의 상수 c와 n0이 존재하며 모든 n >= n0에 대하여
    * f(n) <= c * g(n)이면 f(n) = O(g(n))이다.
    * 최악의 수행시간을 나타내기 위한 표기법
  * 점근적 하한
    * 어떤 양의 상수 c와 n0이 존재하며 모든 n >= n0에 대하여
    * f(n) >= c * g(n)이면 f(n) = 오메가(g(n))이다.
  * 점근적 상하한
    * 어떤 양의 상수 c와 n0이 존재하며 모든 n >= n0에 대하여
    * c1 * g(n) <= f(n) <= c2 * g(n)이면 f(n) = 세타(g(n))이다.
* 점근 성능의 표기법
  * f(n) = O(g(n)) = O(n^3) -> 가장 낮은 차수의 함수만 표기한다
  * f(n) = 오메가(g(n)) = 오메가(n^3) -> 가장 높은 차수의 함수만 표기한다.
  * 주요 O-표기 간의 연산 시간의 크기 관계
    * O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)
* 시간 복잡도 구하기
  * 알고리즘 수행시간 f(n)을 구한 후
  * f(n) = O(g(n))을 만족하는 최소 차수의 함수 g(n)을 찾음
  * 실용적 접근과정
    * 알고리즘에 나타난 루프의 반복횟수를 조사하여 시간 복잡도로 취합
    * g(n)은 최고 차수에 의존

## 순환 알고리즘의 성능

* 순환Recursive 재귀
  * 알고리즘 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태
  * 점화식으로 나타나게 됨
  * T(n) = T(n/2) + O(1), T(1) = C1
  * = 세타(logn)
  * 기본 점화식이 있음. 확인해서 추가할 것
  * 